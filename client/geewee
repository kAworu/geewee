#!/usr/bin/env ruby
#
#   __ _  ___  _____      _____  ___
#  / _` |/ _ \/ _ \ \ /\ / / _ \/ _ \
# | (_| |  __/  __/\ V  V /  __/  __/
#  \__, |\___|\___| \_/\_/ \___|\___|
#  |___/
#
# geewee client, see http://hg.kaworu.ch/rails-geewee.
#   this client need json in order to be able to use the geewee JSON API.
#
require 'yaml'
require 'rubygems'

begin
    require 'json'
    require 'json/add/rails'
rescue LoadError => e
    STDERR.puts <<-EOF
#{e.class}: #{e}

    this client need json in order to be able to use the geewee JSON API.
    please run:
        gem install json_pure
    EOF
    exit 1
end

# Extending ruby for greater justice. {{{
#   main / usage / error function.
#

# main procedure called if this script is executed.
def main
    # FIXME: UGLY UGLY UGLY
    # basic config setup.
    $config = YAML.load(DATA.read)
    unless $config and $config[:base_url]
        STDERR.puts 'Config is missing :base_url'
        exit 1
    end

    case ARGV.size
    when 2 # operation resource
      operation, resource, id, argument = ARGV[0], ARGV[1], nil,     nil
    when 3 # operation resource argument
      operation, resource, id, argument = ARGV[0], ARGV[1], nil,     ARGV[2]
    when 4 # operation resource id argument
      operation, resource, id, argument = ARGV[0], ARGV[1], ARGV[2], ARGV[3]
    else   # fail.
        usage 'wrong # of arguments'
        exit 1
    end
    # find the resource wanted.
    rclass = Geewee::Resources::detect(resource.downcase.to_sym)
    usage "couldn't find resource #{ressource}" unless rclass
    r = rclass.new Geewee::REST::Connection.new($config[:base_url], $config)
    r.apply Geewee::Action.new  :operation  => operation.downcase.to_sym,
                                :id         => id,
                                :argument   => argument
end


# dynamic usage function
def usage message
    STDERR.puts "#{__FILE__}: #{message}"
    STDERR.puts
    STDERR.puts "usage: #{__FILE__} operation ressource"
    STDERR.puts "       #{__FILE__} operation ressource argument"
    STDERR.puts "       #{__FILE__} operation ressource id argument"

    # Build the operation -> resource help.
    h = Hash.new
    Geewee::Resources.all.each do |r|
        r.operations.keys.each do |op|
            (h[op] ||= Array.new) << r
        end
    end
    # and  display it
    STDERR.puts
    STDERR.puts "operations and resources:"
    STDERR.puts "========================>"
    h.each do |op, rs|
        rsstr = rs.collect { |r| r.resources.join('|') }.join(', ')
        STDERR.puts '- %10s: %s' % [op, rsstr]
    end
end

# really simple error function.
def error message
    STDERR.puts "#{__FILE__}: #{message}"
    exit 1
end

# ask the user
def ask question
  STDOUT.print question
  STDOUT.flush
  STDIN.gets.chomp
end

# Object#instance_eval can't pass argument to the block. Ruby 1.9 will define
# Object#instance_exec but for 1.8 we hack it.
#   see http://www.ruby-forum.com/topic/54096.
class Object
    def instance_exec(*args, &block)
        mname = "__instance_exec_#{Thread.current.object_id.abs}"
        class << self; self end.class_eval{ define_method(mname, &block) }
        begin
            ret = send(mname, *args)
        ensure
            class << self; self end.class_eval{ undef_method(mname) } rescue
            nil
        end
        ret
    end
end if RUBY_VERSION < '1.9.0'
#}}}


# My Shiny Geewee module <3
module Geewee
# stolen and hacked REST module {{{
#   from http://snipplr.com/view.php?codeview&id=2476
#
require 'net/https'
module REST

    # all HTTP methods.
    HTTPMethods = {
        :GET    => Net::HTTP::Get,
        :POST   => Net::HTTP::Post,
        :PUT    => Net::HTTP::Put,
        :DELETE => Net::HTTP::Delete,
    }

    # HTTP connection handler class.
    class Connection
        def initialize(base_url, args = {})
            @base_url = base_url
            @username = args[:username]
            @password = args[:password]
        end

        # send the HTTP request, method should be a key of HTTPMethods.
        def request(resource, method, args)
            url = URI.join(@base_url, resource)

            if args
                # TODO: What about keys without value?
                url.query = args.map do |k,v|
                    '%s=%s' % [URI.encode(k), URI.encode(v)]
                end.join('&')
            end

            req = HTTPMethods[method].new(url.request_uri)

            if @username and @password
                req.basic_auth(@username, @password)
            end

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = (url.port == 443)

            res = http.start { |conn| conn.request(req) }
            res
        end
    end
end
# }}}

# Resources module and bases classes {{{
#   modules and functions used to implements Resources management.
#

# contains all Resources and find them.
module Resources
    # This is where all Resources classes belongs.
    module All end

    # return all Resources in the All module, as Class objects.
    def self.all
        self::All.constants.collect { |const| eval "self::All::#{const}" }
    end

    # Auto-detect available resources.
    #   target argument must be a symbol.
    def self.detect target
        all.each do |klass|
            return klass if klass.resources.include?(target)
        end
        nil # couldn't find it!
    end
end

# Contains an operation to apply with an optional id and an optional argument.
class Action
    attr_reader :op, :id, :argument

    # create a new Action with a hash of parameters.
    def initialize hash
        @op        = hash[:operation].to_sym
        @id        = hash[:id]
        @argument  = hash[:argument]
    end
end


# Base class for Resources.
class Resources::Base
    All = [:create, :show, :update, :destroy]

    # conn is a REST::Connection instance.
    def initialize conn
        @conn = conn
    end

    # Array of name matching this Resource.
    #   it's composed of symbols like [:category, :categories] that are alias.
    #   The first symbol is used as reference name for HTTP request.
    def self.resources
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @resources ||= Array.new
    end

    # Hash of supported operations for this class.
    #   it's a Hash from operations keys (like :show) to lambda functions that
    #   take two arguments, id and argument (that can be nil).
    def self.operations
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @operations ||= Hash.new
    end

    # Do the given action if possible.
    def apply action
        ops = self.class.operations
        unless ops.key?(action.op)
            usage "#{action.op}: operation not supported by #{self.class}\n" +
                  "Supported operations are: #{ops.keys.join(', ')}"
        else
            f = ops[action.op]
            instance_exec(action.id, action.argument, &f)
        end
    end

    protected

    # declare which name this resource is responsible for, used for HTTP request.
    def self.named_resource name
        # put it as first element.
        resources.unshift name
    end

    # declare aliases for the resource.
    def self.alias_resource *list
        # add them at the end
        (resources << list).flatten!
    end

    # declare which operations are accepted.
    def self.accept(op, &block)
        operations[op] = block
    end

    # helpers for HTTP request.
    def get(id=nil, args=nil)
        request(id, :GET, args)
    end
    def post(id=nil, args=nil)
        request(id, :POST, args)
    end
    def put(id=nil, args=nil)
        request(id, :PUT, args)
    end
    def delete(id=nil, args=nil)
        request(id, :DELETE, args)
    end

    def request(id, method, args)
        if id and not args
            args = id
            id = nil
        end
        resource =  '/' + self.class.resources.first.to_s
        resource << "/#{id}" if id
        resource << '.json'
        res = @conn.request(resource, method, args)
        JSON.parse(res.body)
    end
end
# }}}

# Category Resource {{{
#   TODO
#
class Resources::All::Category < Resources::Base
    private

    # accept plural form
    named_resource :categories
    alias_resource :category

    # id and arg are ignored, always display a list of Category.
    accept :show do |id, arg|
        categories = get
        # TODO handle error.
        categories.each { |h| display h['category'] }
    end

    # id and arg are ignored, the user is asked for the display_name on the
    # cli.
    accept :create do |id, arg|
        n = ask 'new Category name: '
        x= post '[category]display_name' => n
        puts x
    end

    # print category on stdout
    def display category
        puts "#{category['id']}. #{category['display_name']}"
    end
end


# }}}
end # end of Geewee module.


# run main procedure if we're executed!
main if $0 == __FILE__


###
# Config for the geewee client in YAML, example:
=begin

---
:base_url:   http://my.sexy.geewee/blog/path
:user:       username
:password:   secret

=end


__END__
---
:base_url:   http://localhost:3000
