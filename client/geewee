#!/usr/bin/env ruby
#
#   __ _  ___  _____      _____  ___
#  / _` |/ _ \/ _ \ \ /\ / / _ \/ _ \
# | (_| |  __/  __/\ V  V /  __/  __/
#  \__, |\___|\___| \_/\_/ \___|\___|
#  |___/
#
# geewee client, see http://hg.kaworu.ch/rails-geewee.
#   this client need json in order to be able to use the geewee JSON API.
#
require 'yaml'
require 'rubygems'

begin
    require 'json'
    require 'json/add/rails'
rescue LoadError => e
    STDERR.puts <<-EOF
#{e.class}: #{e}

    this client need json in order to be able to use the geewee JSON API.
    please run:
        gem install json_pure
    or
        gem install json
    EOF
    exit 1
end

# Extending ruby for greater justice. {{{
#   main / usage / error function.
#

# main procedure called if this script is executed.
def main
    # FIXME: UGLY UGLY UGLY
    # basic config setup.
    $config = YAML.load(DATA.read)
    unless $config and $config['base_url']
        STDERR.puts "Config is missing `base_url'"
        exit 1
    end

    if ARGV.size < 2
        usage 'wrong # of arguments'
        exit 1
    end

    operation = ARGV.shift
    resource  = ARGV.shift
    argv      = ARGV

    # find the resource wanted.
    rclass = Geewee::Resources::detect(resource.downcase.to_sym)
    usage "couldn't find resource #{ressource}" unless rclass
    r = rclass.new Geewee::REST::Connection.new($config['base_url'], $config)
    r.apply :operation  => operation.downcase.to_sym,
            :resource   => resource,
            :argv       => argv
end


# dynamic usage function
def usage message
    STDERR.puts "#{__FILE__}: #{message}"
    STDERR.puts
    STDERR.puts "usage: #{__FILE__} operation ressource [arguments...]"
    STDERR.puts
    STDERR.puts "CRUD operations:"
    STDERR.puts "===============>"
    STDERR.puts "\t#{__FILE__} create ressource"
    STDERR.puts "\t#{__FILE__} create ressource /path/to/file"
    STDERR.puts "\t#{__FILE__} show resource"
    STDERR.puts "\t#{__FILE__} show resource id"
    STDERR.puts "\t#{__FILE__} update ressource"
    STDERR.puts "\t#{__FILE__} update ressource id"
    STDERR.puts "\t#{__FILE__} update ressource id /path/to/file"
    STDERR.puts "\t#{__FILE__} destroy ressource"
    STDERR.puts "\t#{__FILE__} destroy ressource id"

    # Build the operation -> resource help.
    h = Hash.new
    Geewee::Resources.all.each do |r|
        r.operations.keys.each do |op|
            (h[op] ||= Array.new) << r
        end
    end
    # and  display it
    STDERR.puts
    STDERR.puts "operations and resources:"
    STDERR.puts "========================>"
    h.each do |op, rs|
        rsstr = rs.collect { |r| r.resources.join('|') }.join(', ')
        STDERR.puts '- %10s: %s' % [op, rsstr]
    end
end

# really simple error function.
def error message
    STDERR.puts "#{__FILE__}: #{message}"
    exit 1
end

# ask the user
def ask question
    STDOUT.print question
    STDOUT.flush
    STDIN.gets.chomp
end

# ask the user
def yesno question
    ans = String.new
    until ans =~ /^\s*(?:y(?:es)?|no?)\s*$/i
        STDOUT.print question + '? [y/n]: '
        STDOUT.flush
        ans = STDIN.gets.chomp
    end
    ans =~ /y(?:es)?/
end

# Object#instance_eval can't pass arguments to the block. Ruby 1.9 will define
# Object#instance_exec but for 1.8 we hack it.
#   see http://www.ruby-forum.com/topic/54096.
class Object
    def instance_exec(*args, &block)
        mname = "__instance_exec_#{Thread.current.object_id.abs}"
        class << self; self end.class_eval{ define_method(mname, &block) }
        begin
            ret = send(mname, *args)
        ensure
            class << self; self end.class_eval{ undef_method(mname) } rescue
            nil
        end
        ret
    end
end if RUBY_VERSION < '1.9.0'
# }}}

# My Shiny Geewee module <3
module Geewee
# stolen and hacked REST module {{{
#   from http://snipplr.com/view.php?codeview&id=2476
#
require 'net/https'
module REST

    # all HTTP methods.
    Methods = {
        :GET    => Net::HTTP::Get,
        :POST   => Net::HTTP::Post,
        :PUT    => Net::HTTP::Put,
        :DELETE => Net::HTTP::Delete,
    }

    # HTTP connection handler class.
    class Connection
        def initialize(base_url, args = {})
            @base_url = base_url
            @username = args[:username]
            @password = args[:password]
        end

        # send the HTTP request, method should be a key of Methods.
        def request(resource, method, args)
            url = URI.join(@base_url, resource)

            if args
                # TODO: What about keys without value?
                url.query = args.map do |k,v|
                    v ||= String.new
                    '%s=%s' % [URI.encode(k), URI.encode(v)]
                end.join('&')
            end

            req = Methods[method].new(url.request_uri)

            if @username and @password
                req.basic_auth(@username, @password)
            end

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = (url.port == 443)

            res = http.start { |conn| conn.request(req) }
            res
        end
    end
end
# }}}

# Resources module and bases classes {{{
#   modules and functions used to implements Resources management.
#

# contains all Resources and find them.
module Resources
    # This is where all Resources classes belongs.
    module All end

    # return all Resources in the All module, as Class objects.
    def self.all
        self::All.constants.collect { |const| eval "self::All::#{const}" }
    end

    # Auto-detect available resources.
    #   target argument must be a symbol.
    def self.detect target
        all.each do |klass|
            return klass if klass.resources.include?(target)
        end
        nil # couldn't find it!
    end
end

# Base class for Resources.
class Resources::Base
    All = [:create, :show, :update, :destroy]

    # conn is a REST::Connection instance.
    def initialize conn
        @conn = conn
    end

    # Array of name matching this Resource.
    #   it's composed of symbols like [:category, :categories] that are alias.
    #   The first symbol is used as reference name for HTTP request.
    def self.resources
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @resources ||= Array.new
    end

    # Hash of supported operations for this class.
    #   it's a Hash from operations keys (like :show) to lambda functions that
    #   take two arguments, id and file (that can be nil).
    def self.operations
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @operations ||= Hash.new
    end

    # Do the given action if possible.
    def apply(h)
        ops = self.class.operations
        unless ops.key?(h[:operation])
            raise ArgumentError.new(
                "#{h[:operation]}: operation not supported by #{self.class}\n" +
                "Supported operations are: #{ops.keys.join(', ')}"
            )
        else
            f = ops[h[:operation]]
            instance_exec(h, &f)
        end
    end

    protected

    # declare which name this resource is responsible for, used for HTTP request.
    def self.named_resource name
        # put it as first element.
        resources.unshift name
    end

    # declare aliases for the resource.
    def self.alias_resource *list
        # add them at the end
        (resources << list).flatten!
    end

    # declare which operations are accepted.
    def self.accept(op, &block)
        operations[op] = block
    end

    # helpers for HTTP request.
    def get(id=nil, args=nil)
        request(id, :GET, args)
    end
    def post(id=nil, args=nil)
        request(id, :POST, args)
    end
    def put(id=nil, args=nil)
        request(id, :PUT, args)
    end
    def delete(id=nil, args=nil)
        request(id, :DELETE, args)
    end

    def request(id, method, args)
        if id and not args and id.is_a?(Hash)
            args = id
            id = nil
        end
        resource =  '/' + self.class.resources.first.to_s
        resource << "/#{id}" if id
        resource << '.json'
        @conn.request(resource, method, args)
    end
end

# Resource File
#   Handle a human readable Resource description.
#   RFile looks like email, a header of key:values, an empty line and a body.
class RFile
    attr_accessor :head, :body

    # create a new RFile.
    #   if head is an Array, it is a list of empty header keys.
    def initialize(head=nil, body=String.new)
        @body = body
        @head = Hash.new
        head.each { |k,v| @head[k] = v } if head
    end

    # parse a file argument, if `-' STDIN is used.
    def parse path
        fd    = if path == '-' then STDIN else File.open(path) end
        data  = fd.read
        @head = Hash.new
        @body = nil
        data.split("\n").each do |line|
            if @body.nil?
                # parsing head.
                if line.empty?
                    @body = String.new
                elsif line =~ /^(.+?):(.*)$/
                    @head[$1.strip] = $2.strip
                else
                    raise SyntaxError.new("bad RFile header line: #{line}")
                end
            else
                @body << line << "\n"
            end
        end
        self
    end

    def to_s
        s = String.new
        @head.each { |k,v| s << "#{k}: #{v}\n" }
        s << @body
    end

    # save the RFile in a tempfile, and return the tempfile's path.
    def save!
        path = "/tmp/#{File.basename(__FILE__)}_#{Time.now.to_i}"
        File.open(path, 'w') { |fd| fd << self.to_s }
        path
    end
end
# }}}

# Category Resource {{{
#   TODO
#
class Resources::All::Category < Resources::Base
    private
    # keys for the geewee API.
    module Keys
        DISPLAY_NAME = '[category]display_name'
    end

    # accept plural form
    named_resource :categories
    alias_resource :category

    # always display a list of Category.
    #   show category
    #   show category id
    accept :show do |h|
        id = h[:argv].first rescue nil

        case response = get(id)
        when ::Net::HTTPOK
            JSON.parse(response.body).each { |h| display h['category'] }
        else
            error response.class
        end
    end

    # create a new category.
    #   generate a stub file:
    #       create category
    #   load from STDIN:
    #       create category -
    #   load from file:
    #       create category /path/to/stub/file
    accept :create do |h|
        file = h[:argv].first rescue nil
        if file
            rf = RFile.new.parse(file)
            case response = post(rf.head)
            when ::Net::HTTPCreated
                puts 'new Category created.'
                display JSON.parse(response.body)['category']
            else
                msg = JSON.parse(response.body).collect do |err|
                    err.join(' ')
                end.join("\n")
                error "#{response.message}\n#{msg}"
            end
        else
            rf = RFile.new [Keys::DISPLAY_NAME]
            path = rf.save!
            puts "edit #{path} and then call:\n" +
                "   #{$0} #{h[:operation]} #{h[:resource]} #{path}"
        end
        name = rf.head[Keys::DISPLAY_NAME]
    end

    # destroy a category.
    #   destroy category
    #   destroy category 1
    accept :destroy do |h|
        id = h[:argv].first rescue nil
        unless id
            # display categories
            self.apply  :operation => :show,
                        :resource  => h[:resource]
            id = ask 'target Category id to destroy: '
        end
        case response = get(id)
        when ::Net::HTTPOK
            c = JSON.parse(response.body)['category']
        else
            error response.class
        end
        if yesno("destroy Category `#{c['display_name']}'")
            case response = delete(id)
            when ::Net::HTTPOK
                puts "Category `#{c['display_name']}' destroyed."
            else
                error response.class
            end
        end
    end

    # print category on stdout
    def display category
        puts "#{category['id']}. #{category['display_name']}"
    end
end
# }}}
end # end of Geewee module.


# run main procedure if we're executed!
main if $0 == __FILE__


###
# Config for the geewee client in YAML, example:
=begin

---
base_url:   http://my.sexy.geewee/blog/path
user:       username
password:   secret

=end


__END__
---
base_url:   http://localhost:3000
