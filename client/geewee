#!/usr/bin/env ruby
#
#   __ _  ___  _____      _____  ___
#  / _` |/ _ \/ _ \ \ /\ / / _ \/ _ \
# | (_| |  __/  __/\ V  V /  __/  __/
#  \__, |\___|\___| \_/\_/ \___|\___|
#  |___/
#
# geewee client, see http://hg.kaworu.ch/rails-geewee.
#   this client need json in order to be able to use the geewee JSON API.
#
require 'yaml'
require 'rubygems'

begin
    require 'json'
    require 'json/add/rails'
rescue LoadError => e
    STDERR.puts <<-EOF
#{e.class}: #{e}

    this client need json in order to be able to use the geewee JSON API.
    please run:
        gem install json_pure
    EOF
    exit 1
end

# Extending ruby for greater justice. {{{
#   main / usage / error function.
#

# main procedure called if this script is executed.
def main
    # FIXME: UGLY UGLY UGLY
    # basic config setup.
    $config = YAML.load(DATA.read)
    unless $config and $config[:base_url]
        STDERR.puts 'Config is missing :base_url'
        exit 1
    end

    # find the resource wanted.
    res = Geewee::Resources::detect(ARGV[1].downcase.to_sym)
    usage "couldn't find resource #{ARGV[1]}" unless res
    r = res.new Geewee::REST::Connection.new($config[:base_url], $config)
    r.apply Geewee::Action.new :operation => ARGV[0]
end


# dynamic usage function
def usage message
    STDERR.puts "#{__FILE__}: #{message}"
    STDERR.puts
    STDERR.puts "usage: #{__FILE__} operation ressource [id] [argument]"

    # Build the operation -> resource help.
    h = Hash.new
    Geewee::Resources.all.each do |r|
        r.operations.keys.each do |op|
            (h[op] ||= Array.new) << r
        end
    end
    # and  display it
    STDERR.puts
    STDERR.puts "operations and resources:"
    STDERR.puts "========================>"
    h.each do |op, rs|
        rsstr = rs.collect { |r| r.resources.join('|') }.join(', ')
        STDERR.puts '- %10s: %s' % [op, rsstr]
    end
    exit 1
end

# really simple error function.
def error message
    STDERR.puts "#{__FILE__}: #{message}"
    exit 1
end

# Object#instance_eval can't pass argument to the block. Ruby 1.9 will define
# Object#instance_exec but for 1.8 we hack it.
#   see http://www.ruby-forum.com/topic/54096.
class Object
    def instance_exec(*args, &block)
        mname = "__instance_exec_#{Thread.current.object_id.abs}"
        class << self; self end.class_eval{ define_method(mname, &block) }
        begin
            ret = send(mname, *args)
        ensure
            class << self; self end.class_eval{ undef_method(mname) } rescue
            nil
        end
        ret
    end
end if RUBY_VERSION < '1.9.0'
#}}}


# My Shiny Geewee module <3
module Geewee
# stolen and hacked REST module {{{
#   from http://snipplr.com/view.php?codeview&id=2476
#
require 'net/https'
module REST

    # all HTTP methods.
    HTTPMethods = {
        :GET    => Net::HTTP::Get,
        :POST   => Net::HTTP::Post,
        :PUT    => Net::HTTP::Put,
        :DELETE => Net::HTTP::Delete,
    }

    # HTTP connection handler class.
    class Connection
        def initialize(base_url, args = {})
            @base_url = base_url
            @username = args[:username]
            @password = args[:password]
        end

        # send the HTTP request, method should be a key of HTTPMethods.
        def request(resource, method, args)
            url = URI.join(@base_url, resource)

            if args
                # TODO: What about keys without value?
                url.query = args.map do |k,v|
                    '%s=%s' % [URI.encode(k), URI.encode(v)]
                end.join('&')
            end

            req = HTTPMethods[method].new(url.request_uri)

            if @username and @password
                req.basic_auth(@username, @password)
            end

            http = Net::HTTP.new(url.host, url.port)
            http.use_ssl = (url.port == 443)

            res = http.start { |conn| conn.request(req) }
            res.body
        end
    end
end

# define HTTP methods and handle REST::Connection object.
module Connectable
    def initialize conn
        @conn = conn
    end

    def get(resource, args=nil)
        @conn.request(resource, :GET, args)
    end

    def post(resource, args=nil)
        @conn.request(resource, :POST, args)
    end

    def put(resource, args=nil)
        @conn.request(resource, :PUT, args)
    end

    def delete(resource, args=nil)
        @conn.request(resource, :DELETE, args)
    end
end
# }}}

# Resources module and bases classes {{{
#   modules and functions used to implements Resources management.
#

# contains all Resources and find them.
module Resources
    # This is where all Resources classes belongs.
    module All end

    # return all Resources in the All module, as Class objects.
    def self.all
        self::All.constants.collect { |const| eval "self::All::#{const}" }
    end

    # Auto-detect available resources.
    #   target argument must be a symbol.
    def self.detect target
        self.all.each do |klass|
            return klass if klass.resources.include?(target)
        end
        nil # couldn't find it!
    end
end

# Contains an operation to apply with an optional id and an optional argument.
class Action
    attr_reader :op, :id, :argument

    # create a new Action with a hash of parameters.
    def initialize hash
        @op        = hash[:operation].to_sym
        @id        = hash[:id]
        @argument  = hash[:argument]
    end
end


# Base class for Resources.
class Resources::Base
    # CRUD operations.
    All = [:create, :show, :edit, :destroy]

    # Array of name matching this Resource.
    #   it's composed of symbols like [:category, :categories] that are alias.
    def self.resources
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @resources ||= Array.new
    end

    # Hash of supported operations for this class.
    #   it's a Hash from operations keys (like :show) to lambda functions that
    #   take two arguments, id and argument (that can be nil).
    def self.operations
        # NOTE: the current context is class, so it is a class instance
        #       variable.
        @operations ||= Hash.new
    end

    # Do the given action if possible.
    def apply action
        ops = self.class.operations
        unless ops.key?(action.op)
            usage "#{action.op}: operation not supported by #{self.class}\n" +
                  "Supported operations are: #{ops.keys.join(', ')}"
        else
            f = ops[action.op]
            instance_exec(action.id, action.argument, &f)
        end
    end

    protected

    # declare which name this resources is responsible for.
    def self.named_resource *list
        (resources << list).flatten!
    end

    # declare which operations are accepted.
    def self.accept(op, &block)
        operations[op] = block
    end
end
# }}}

# Category Resource {{{
#   TODO
#
class Resources::All::Category < Resources::Base
    private
    include Connectable

    # accept plural form
    named_resource :category, :categories

    # id and arg are ignored, always display a list of Category.
    accept :show do |id, arg|
        require "pp"
        pp list
        l = list
        l.each do |c|
            c   = c['category']
            uri = "#{$config[:base_url]}/archives/by_category/#{c['cached_slug']}"
            puts '%d. %s (%s)' % [c['id'], c['display_name'], uri]
        end
    end

    # return the Category list.
    def list
        JSON.parse(get('/categories.json'))
    end
end


# }}}
end # end of Geewee module.


# run main procedure if we're executed!
main if $0 == __FILE__


###
# Config for the geewee client in YAML, example:
=begin

---
:base_url:   http://my.sexy.geewee/blog/path
:user:       username
:password:   secret

=end


__END__
---
:base_url:   http://localhost:3000
